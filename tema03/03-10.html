<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Servidores Web</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <header>
        <div>Servidores Web</div>
    </header>

    <section class="contenido-didactico">

        <h2>2.4. Modelos de arquitecturas web</h2>

        <p>La arquitectura de un sitio web comprende la organización de sus componentes, la estructura de la
            información, los sistemas de navegación, y cómo estos elementos trabajan conjuntamente para servir a los
            usuarios. Una buena arquitectura web facilita que los usuarios encuentren lo que buscan y que los
            desarrolladores mantengan y evolucionen el sistema.</p>

        <h3>Capas de una aplicación web</h3>

        <p>Las aplicaciones web modernas típicamente se organizan en tres capas lógicas</p>

        <figure>
            <img src="https://pfst.cf2.poecdn.net/base/image/b829cd827b7edd68b1f494aa9fdcec65b915b142113995c5fb51b9f14edae37f?w=1536&h=1024"
                alt="Imagen didáctica 2">
            <figcaption>Arquitectura en capas.</figcaption>
        </figure>

        <h4>Capa de presentación (Frontend)</h4>
        <p>Lo que el usuario ve e interactúa.</p>
        <ul>
            <li><strong>Responsabilidades:</strong> interfaz de usuario, experiencia de usuario (UX), validación de
                entrada de datos (lado cliente), navegación, formato y visualización de datos.</li>
            <li><strong>Tecnologías:</strong> HTML, CSS, JavaScript, frameworks frontend.</li>
            <li>En 2025, cada vez más lógica se ejecuta en esta capa (SPAs, PWAs).</li>
        </ul>

        <h4>Capa de lógica de negocio (Backend)</h4>
        <p>El "cerebro" de la aplicación.</p>
        <ul>
            <li><strong>Responsabilidades:</strong> procesamiento de peticiones, aplicación de reglas de negocio,
                validación de datos (lado servidor), autenticación y autorización, orquestación entre diferentes
                servicios, generación de respuestas.</li>
            <li><strong>Tecnologías:</strong> lenguajes de servidor (PHP, Python, Java, Node.js), frameworks backend.
            </li>
        </ul>

        <h4>Capa de datos (Database)</h4>
        <p>Almacenamiento persistente de información.</p>
        <ul>
            <li><strong>Responsabilidades:</strong> almacenamiento de datos, recuperación eficiente de información,
                integridad y consistencia de datos, respaldo y recuperación.</li>
            <li><strong>Tecnologías:</strong> bases de datos relacionales (MySQL, PostgreSQL, SQL Server), bases de
                datos NoSQL (MongoDB, Redis, Cassandra), sistemas de archivos, servicios de almacenamiento en la nube.
            </li>
        </ul>

        <p>Esta separación en capas ofrece importantes beneficios:</p>
        <ul>
            <li><strong>Mantenibilidad:</strong> cambios en una capa no afectan a las otras.</li>
            <li><strong>Escalabilidad:</strong> puedes escalar cada capa independientemente.</li>
            <li><strong>Reutilización:</strong> la misma lógica de negocio puede servir a múltiples interfaces (web,
                móvil, API).</li>
            <li><strong>Seguridad:</strong> cada capa puede tener sus propias medidas de seguridad.</li>
            <li><strong>Desarrollo paralelo:</strong> diferentes equipos pueden trabajar en diferentes capas.</li>
        </ul>

        <h3>Modelos arquitectónicos históricos</h3>

        <p>La arquitectura de aplicaciones web ha evolucionado significativamente:</p>

        <h4>Modelo 1 (CGI tradicional)</h4>
        <ul>
            <li>Una única capa mezclaba presentación, lógica, y acceso a datos.</li>
            <li>Scripts (típicamente Perl) que generaban HTML directamente.</li>
            <li>Difícil de mantener y escalar.</li>
            <li>Muy ineficiente (nuevo proceso por cada petición).</li>
            <li>Prácticamente obsoleto en 2025.</li>
        </ul>

        <h4>Modelo 1.5 (Tecnologías de scripting del servidor)</h4>
        <ul>
            <li>Separación básica entre lógica y presentación.</li>
            <li>En Java: JSP (presentación) + JavaBeans (lógica).</li>
            <li>En PHP: plantillas PHP + funciones de lógica.</li>
            <li>Mejor que el Modelo 1, pero aún con acoplamiento significativo.</li>
        </ul>

        <h4>Modelo 2 (MVC — Modelo Vista Controlador)</h4>
        <p>Paradigma arquitectónico que separa claramente responsabilidades:</p>
        <ul>
            <li><strong>Modelo:</strong> datos y lógica de negocio.</li>
            <li><strong>Vista:</strong> presentación (lo que ve el usuario).</li>
            <li><strong>Controlador:</strong> gestiona peticiones, coordina modelo y vista.</li>
        </ul>
        <p><strong>Ventajas:</strong> separación de responsabilidades clara, testeable, mantenible, reutilizable.</p>
        <p><strong>Frameworks MVC en 2025:</strong> Spring MVC (Java), ASP.NET MVC, Ruby on Rails, Laravel (PHP), Django
            (Python).</p>
        <p>Sigue siendo muy popular en 2025.</p>

        <h4>Modelo 2X (MVC con XML/XSLT para multi-canal)</h4>
        <ul>
            <li>Extensión del Modelo 2 para servir múltiples tipos de clientes.</li>
            <li>El servidor genera XML con los datos.</li>
            <li>Transformaciones XSLT diferentes según el dispositivo (HTML para web, WML para móviles antiguos, etc.).
            </li>
            <li>Fue popular en 2005-2010 pero ha sido superado por enfoques más modernos.</li>
        </ul>

        <h3>Arquitecturas modernas en 2025</h3>

        <h4>API-First / Backend-for-Frontend (BFF)</h4>
        <ul>
            <li>El backend expone APIs (generalmente REST o GraphQL).</li>
            <li>Múltiples frontends consumen estas APIs: aplicación web (SPA), aplicación móvil iOS, aplicación móvil
                Android, aplicaciones de escritorio, dispositivos IoT.</li>
            <li>Desacopla completamente frontend y backend.</li>
            <li>Cada frontend puede tener su propio BFF optimizado.</li>
        </ul>

        <h4>Microservicios</h4>
        <p>La aplicación se divide en servicios pequeños e independientes.</p>
        <ul>
            <li>Cada microservicio:
                <ul>
                    <li>Tiene una responsabilidad específica</li>
                    <li>Se puede desarrollar en diferentes tecnologías</li>
                    <li>Se despliega independientemente</li>
                    <li>Se escala independientemente</li>
                </ul>
            </li>
            <li>Comunicación entre servicios vía APIs (HTTP/REST, gRPC, mensajería).</li>
            <li>Complejidad operacional, pero gran flexibilidad.</li>
            <li>Popular en grandes organizaciones en 2025.</li>
        </ul>

        <h4>Serverless / Functions as a Service (FaaS)</h4>
        <ul>
            <li>Código que se ejecuta sin gestionar servidores.</li>
            <li>Funciones que responden a eventos.</li>
            <li>Escalado automático y pago por uso.</li>
            <li>Proveedores: AWS Lambda, Azure Functions, Google Cloud Functions.</li>
            <li>Ideal para cargas de trabajo variables o esporádicas.</li>
        </ul>

        <h4>JAMstack (JavaScript, APIs, Markup)</h4>
        <ul>
            <li>Frontend estático precompilado.</li>
            <li>Funcionalidad dinámica vía JavaScript y APIs.</li>
            <li>CDN (Content Delivery Network) para distribución global.</li>
            <li>Rendimiento excepcional y seguridad mejorada.</li>
            <li>Popular para sitios de contenido y blogs en 2025.</li>
        </ul>
    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
</body>

</html>